---
title: Ch4 Sequential Circuits
sync: /course/dd/note/4.md
---

## 1. Sequential Circuit Analysis

### 1.1. Introduction to Sequential Circuit

我们将某一时刻存储**存储元件(storage element)** 中的二进制信息称为该时刻时序电路的**状态(state)**。

![gyONWRkQ.png|575](https://static.memset0.cn/img/v6/2024/04/18/gyONWRkQ.png)

按照输出除了基于当前状态之外是否依赖于输入，可以将视时序电路分为：

- **Mealy 型电路(Mealy model circuit)**：输出只和前一个状态有关
- **Moore 型电路(Moore model circuit)**：输出和输入及当前输入有关

根据输入信号的时间和内部状态改变的时间，可以将时序电路分为：

- **同步时序电路(synchronous sequential circuit)**：
    - 同步时序电路是通过**时钟发生器(clock generator)** 产生周期性的**时钟脉冲(clock pulse)** 来实现的。
    - 把时钟脉冲作为存储元件输入信号的同步时序电路称为**钟控时序电路(clocked sequential circuit)**。
- **异步时序电路(asynchronous sequential circuit)**：
    - Behavior defined by knowledge of inputs at any instant of time and the order in continuous time in which inputs change
    - If clock is regarded as another input, all circuits are asynchronous!
    - Nevertheless, the synchronous abstraction makes complex designs tractable!

### 1.2. 离散事件模拟 Discrete Event Simulation

可以通过**离散事件模拟(discrete event simulation)** 来更好的理解时序电路的时间行为。离散事件模拟的规则如下：

![fal07yxB.png|475](https://static.memset0.cn/img/v6/2024/04/18/fal07yxB.png)

我们以一个二路选择器为例：

![nYKitFyS.png|569](https://static.memset0.cn/img/v6/2024/04/18/nYKitFyS.png)

- **毛刺(glitch)**：或称瞬态错误。当 $S$ 从 $1$ 变为 $0$ 时，由于非门有 0.2ns 的延迟，由 $A \overline{S}$

如果把选择器的输出 $Y$ 直接连到输入 $A$ 上呢？

![JR6iiTsg.png|585](https://static.memset0.cn/img/v6/2024/04/18/JR6iiTsg.png)

- 这里的 Y 不仅是输出，还可以记忆电路的**状态(state)**。

如果再多加一个**反相器(inverter)** 呢？

时钟发生器

## 2. 锁存器 Latchs

### 2.1. S'R'锁存器 $\overline{S}-\overline{R}$ Latch

![3Ihpxlbj.png|333](https://static.memset0.cn/img/v6/2024/04/18/3Ihpxlbj.png)

![UF84A6ep.png|396](https://static.memset0.cn/img/v6/2024/04/18/UF84A6ep.png)

- $\overline{S}-\overline{R}$ **锁存器(latch)** 是 0 触发的。即将 set 端置 0（$S=0$，$R=1$）时 $Q$ 被置为 1；reset 端置 0 （$S=1$，$R=0$）时 $Q$ 被置为 0。
- $S=0,\ R=0$ 是**禁止的(forbidden)** 或者**未定义的(undefined)**，此时输出端 $Q=1$ 和 $\overline{Q}=1$ 同时成立。一般不使用这种状态。
- 如果 $R$ 和 $S$ 同时从 0 变成 1，则输出是**不稳定的(unstable)**。如果两个与非门的实验完全相同，则输出会在 01 之间震荡，否则会稳定在 $Q=0$ 或 $Q=1$ 中的一个状态，取决于两个与非门的时延。

### 2.2. SR 锁存器 S-R Latch

![1YXNEnfT.png|338](https://static.memset0.cn/img/v6/2024/04/18/1YXNEnfT.png)

![SNyhcSa0.png|451](https://static.memset0.cn/img/v6/2024/04/18/SNyhcSa0.png)

- $S-R$ 锁存器是 1 触发的。

### 2.3. Clocked S-R Latch

多输入一路时间信号 $C$ 与 $S,R$ 信号作与或，可将 Basic $\overline{S}-\overline{R}$ Latch 转化为 Clocked $S-R$ Latch。

![BkfC3qgA.png|361](https://static.memset0.cn/img/v6/2024/04/18/BkfC3qgA.png)

![bZAECh0w.png|226](https://static.memset0.cn/img/v6/2024/04/18/bZAECh0w.png)

- 这里 C 的含义可解释为**控制(control)** 或**时钟(clock)** 。当 $C=1$ 时才接受输入，可以改变锁存器的值；当 $C=0$ 时拒绝输入，无论 $S, R$ 给定什么信号锁存器都不保持不变。

### 2.4. D 锁存器 D Latch

给 Clocked S-R Latch 添加一个反相器可以得到**D 锁存器(D latch)**。

![qoXKJ8B2.png|390](https://static.memset0.cn/img/v6/2024/04/18/qoXKJ8B2.png)

| $C$ | $D$ | $Q_{t+1}$ | 描述       |
| --- | --- | --------- | ---------- |
| 0   | X   | $Q_{t}$   | 输出不改变 |
| 1   | 0   | 0         | 复位       |
| 1   | 1   | 1         | 置位       |

当控制输入信号有效（$C=1$）时输出 $Q$ 会根据输入 $D$ 的改变而改变，从这种意义上来讲，锁存器是**透明(transparent)** 的。而当 $C=0$ 时 D 锁存器的输出会维持 $Q$ 不变，直到控制信号再次有效为止。

### 2.5. 锁存器的时序问题 The Latch Timing Problem

锁存器存在**时序问题(timing problem)**：在时钟脉冲有效（$C=1$）时，输入信号的改变随时会引起输出的改变，即上文所说的透明性。那么当时钟脉冲保持为 1 时，锁存器的输入信号可能因为其余锁存器的输出信号的改变而改变，从而在一个时钟周期内发多次变化，这是我们要引入触发器的原因。

如考虑这一电路中，$C=1$ 的时间内 $Y$ 的值会反复振荡，且最后结果不确定。而我们期望的功能时，一整段 $C=1$ 只会导致 $Y$ 的值改变一次。

![bHO3VS6o.png|512](https://static.memset0.cn/img/v6/2024/05/10/bHO3VS6o.png)

一种可行的解决方案是：$C=1$ 时（输入的时候）先不改变输出，等到 $C=0$ 时在改变，这就是主从触发器的原理。

### 2.6. 锁存器的标准符号 Standard Symbols for Latches

![](https://static.memset0.cn/img/v6/2024/04/18/iFJ7MCYp.png)

## 3. 触发器 Flip-Flop

### 3.1. 主从触发器 Master-Slave Flip-Flop

![2ksxJEq7.png|351](https://static.memset0.cn/img/v6/2024/04/18/2ksxJEq7.png)

**主从触发器(master-slave flip-flop)** 一般通过将两个 SR 锁存器先后连接起来所得到，其中前者称为主触发器，后者称为从触发器。

- 第一个触发器观测输入得到 $Q$ 仅在时钟信号的**上升沿(positive edge)** 发生，即 $C$ 被置为 1 的时候。
    第二个触发器改变输出 $Y$ 仅在时钟信号的**下降沿(negative edge)** 发生，即 $C$ 被置为 0 的时候。

一般来说，主从触发器都存在**一次性采样问题(1s catching problem)**：

![WoIhiZRM.png|590](https://static.memset0.cn/img/v6/2024/04/18/WoIhiZRM.png)

为了避免发生一次性采样问题，主从触发器要求其的输入信号在半个时钟周期内不能改变。（TBD：setup time，负脉冲）

TBD

### 3.2. 边缘触发器 Edge-Triggered Filp-Flop

TBD

### 3.3. JK 触发器 J-K Flip-Flop

| $J$ | $K$ | $Q_{t+1}$        | 描述 |
| --- | --- | ---------------- | ---- |
| 0   | 0   | $Q_t$            | 保持 |
| 0   | 1   | 0                | 复位 |
| 1   | 0   | 1                | 设定 |
| 1   | 1   | $\overline{Q_t}$ | 翻转 |

> [!example] 例：写出 JK 触发器的激励表

### 3.4. T 触发器 T Flip-Flop

### 3.5. 触发器的时序参数 Flip-Flop Timing Parameters

$t_s$ - **建立时间(setup time)**：输入数据在时钟信号的上升沿或下降沿到来之前，需要保持稳定的时间。

- 对于主从触发器，为了避免一次性采样问题，其 setup time 应为半个时钟周期。即对于高电平激活的电路，其在时钟信号维持高电平期间不能改变输出。
- 对于边缘触发器，其所需要的 setup time 比主从触发器小很多，但也并不是 $0$。

$t_h$ - **保持时间(hold time)**：输入数据在时钟信号的上升沿或下降沿到来之后，需要保持稳定的时间。

- 经常等于 $0$，即时钟脉冲之后对输入信号是否保持没有要求。

$t_w$ - **时钟脉冲宽度(clock pulse width)**：一个时钟周期中，时钟信号为高电平（$t_{wh}$）或低电平（$t_{wl}$）的时间。取决于触发器是在时钟信号的上升沿触发还是在时钟信号的下降沿触发。

$t_{pd}$ - **传播延迟(propagation delay)**：从时钟信号的上升沿或下降沿（注意这里和组合电路中的定义略有不同）到触发器输出稳定，所需要的时间。其中

- 输出信号从高到低所需要的传播延迟定义为 $t_{\text{PHL}}$；
- 输出信号从低到高所需要的传播延迟定义为 $t_{\text{PLH}}$。

两者可能不同。对触发器传播延迟的定义可取两者的最大值或平均值，如$t_{pd} = \max\{t_{\text{PHL}}, t_{\text{PLH}}\}$

![1zDOCvWd.png|457](https://static.memset0.cn/img/v6/2024/05/10/1zDOCvWd.png)

### 3.6. 触发器的标准符号 Standard Symbols for Flip-Flops

![uiJvlAgB.png|560](https://static.memset0.cn/img/v6/2024/04/18/uiJvlAgB.png)

![EfG4e0AK.png|284](https://static.memset0.cn/img/v6/2024/04/18/EfG4e0AK.png)

### 3.7. 触发器的描述方法

常用于分析（从当前状态和输入中得到下一状态）：

- **特征表(characteristic table)**：定义了下一状态与当前状态和输入的关系。
- **特征方程(characteristic equation)**：用布尔函数来表示下一状态与当前状态和输入的关系。

常用于设计（从状态中得到输入）：

- **激励表(excitation table)**：列出所有可能的当前状态和下一状态，从而确定输入。

## 4. 时序电路分析 Sequential Circuit Analysis

![整体模型|332](https://static.memset0.cn/img/v6/2024/05/10/k6yAYzTF.png)

对于一个输入为 $X$，输出为 $Y$，状态为 $(A,B)$ 的时序电路可以这样定义其：

- **输出方程(output function)**：$y = \overline X (B + A)$。
- **触发器输入方程(flip-flop input equation)**：$D_A = AX+BX,\quad D_B=\overline AX$。
- **次态方程(next state function)**：$A_{t+1} = D_A,\quad B_{t+1} = D_B$。

![来自课本 Figure 5-15|300](https://static.memset0.cn/img/v6/2024/05/10/YOevSc7d.png)

### 4.1. 状态表 State Table

**状态表(state table)** 由四部分组成：**当前状态(present state)**、**输入(input)**、**下一状态(next state)** 和**输出(output)**。

### 4.2. 状态图 State Diagram

我们称呼两个状态是**等价(equivalent)** 的，当且仅当对于任意的输入序列，其输出序列都是相同的。

TBD

> [数字逻辑设计 2024-04-25 第 6-8 节 (zju.edu.cn)](https://classroom.zju.edu.cn/livingroom?course_id=59660&sub_id=1148778&tenant_code=112)看到第一节课下课。

moore型状态图、mealy型状态图

## 5. 时序电路设计 Sequential Circuit Design

### 5.1. 设计步骤 The Design Procedure

|     | 步骤                                               | 内容         |
| --- | -------------------------------------------------- | ------------ |
| 1   | **规格说明(specification)**                        | <br><br><br> |
| 2   | **形式化(formulation)**                            |              |
| 3   | **状态赋值(state assignment)**                     |              |
| 4   | 确定**触发器的输入方程(flip-flop input equation)** |              |
| 5   | 确定**输出方程(output equation)**                  |              |
| 6   | **优化(optimization)**                             |              |
| 7   | **工艺映射(technology mapping)**                   |              |
| 8   | **验证(verification)**                             |              |

![](https://static.memset0.cn/img/v6/2024/05/09/Urf7XFN3.png)

TBD

### 5.2. 状态赋值 State Assignment

用 $n$ 位二进制给 $m$ 种状态各自分配一个不同的编码，需要使用 $n$ 个触发器。剩余 $2^n-m$ 个状态未使用，可视为不定项。

常见的状态赋值方法如下：

| 赋值方法                                 | 特性                                     |
| ---------------------------------------- | ---------------------------------------- |
| 按照**计数的顺序(counting order)** 分配  |                                          |
| 按照**格雷码顺序(Gray code order)** 分配 | 在使用卡诺图作化简时非常方便             |
| **单热点(one-hot)** 赋值                 | 每个状态对应一个触发器，跳变最少效率最高 |

## 6. 状态机

> 听说考试没有考过？
