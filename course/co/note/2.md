---
title: II. Arithmetic
sync: /course/co/note/2.md
cover: https://static.memset0.cn/img/v6/2024/09/10/X7MD2Cti.png
banner: https://static.memset0.cn/img/v6/2024/09/10/X7MD2Cti.png
banner_y: '42'
---

## 1. Numbers

### 1.1. Radix-Based System

![|476](https://static.memset0.cn/img/v6/2024/10/15/prMkGudL.png)

- **最高有效位(Most Significant Digit, MSD)**：$A_{n-1}$
- **最低有效位(Least Significant Digit, LSD)**：$A_{-m}$

### 1.2. Binary Representations

- **原码(sign-magnitude)**
- **反码(1's complement code)**
- **补码(2's complement code)**
- **移码(biased notation)**：IEEE754 标准浮点数的指数部分（阶码）就是使用移码表示的。

对于正数而言，原码=反码=补码，负数一般是通过补码表示的。

## Arithmetic

### Addition & Subtraction

- 加法就是按位相加。
- 减法可以实现为加上另一个数的补码。

两个数的和或差可能超过可以被表示的范围，这种情况下就是发生了 **溢出(overflow)**。

- 对于有符号数运算，正数和正数相加得到负数，或者负数和负数相加得到负数，就可以认为发生了溢出。这里正数包括 $0$。
- 对于无符号数运算，两个数相加的结果小于其中任何一个数，就可以认为发生了溢出。

![一般溢出条件|476](https://static.memset0.cn/img/v6/2024/09/18/wEdNgTlV.png)

## 2. ALU

### 1 bit ALU

AND 和 OR 的功能可以直接使用对应的电路门。

加法功能通过 **一位全加器(1-bit full adder)** 实现（后面直接用“方括号内加号”的组合来表示全加器）：

$$
\begin{aligned}
S &= A \oplus B \oplus C_{\text{in}} \\
C_{\text{out}} &= B \cdot C_{\text{in}} + A \cdot C_{\text{in}} + A \cdot B
\end{aligned}
$$

![|297](https://static.memset0.cn/img/v6/2024/10/15/S4jaIXpe.png)

为了实现减法器，多一个 Binvert 输入控制（而不是通过 Operation 控制）是否需要将输入 B 取反并将第一个 CarryIn 设 1。

![|346](https://static.memset0.cn/img/v6/2024/10/15/fM4X5Czh.png)

这时还缺少比较功能，

---

- slu: set on less than

### 2.1. Comparison

两个计算时会发生 overflow 的数也可以进行比较，比如 `127` 减 `-128`。这时可以通过符号位得到结果，而不用担心减法产生溢出。

### 2.2. Addition

### 2.3. Ripple Carry Adder

**行波进位加法器(Ripple Carry Adder, RCA)**

### 2.4. Carry Lookahead Adder

**超前进位加法器(Carry Lookahead Adder, CLA)** 通过“超前进位”的方式改进 RCA 中后一位必须等待前一位进位结果的问题。

### 2.5. Multiplication

### 2.6. Approach 1

![|606](https://static.memset0.cn/img/v6/2024/09/23/hyGyoyjX.png)

**具体过程**：执行以下步骤 64 次：

1. 判断 Multiplier 寄存器的最低位是否是 1：
2. 如果是，则将 Multiplicand 寄存器的值加到 Product 寄存器里；
3. 如果否，进入下一步；
4. 将 Multiplier 寄存器的值右移一位（这是为了不断拿出每一位，相当于在枚举 Multiplier 的每一位），将 Multiplicand 寄存器的值左移一位（对应于和 Multiplier 的第几位乘得到的位移，具体参考上面的链接内容）；
5. 判断是否做满 64 次，决定是否终止；

#### 2.6.1. Approach 2

![|672](https://static.memset0.cn/img/v6/2024/09/23/48AZ1pcN.png)

**具体过程**：执行以下步骤 64 次：

1. 判断 Multiplier 寄存器的最低位是否是 1：
2. 如果是，则将 Multiplicand 寄存器的值加到 Product 寄存器的左半部分里；
3. 如果否，进入下一步；
4. 将 Multiplier 寄存器的值右移一位，将 Product 寄存器的值右移一位；
5. 判断是否做满 64 次，决定是否终止；

- 注意这里在执行循环的第 2 步时，可能会有加法进位的问题，这一问题也同样会出现在下面的 Approach 3，所以 Product 寄存器需要有 129 位，或者需要通过别的方法存储进位（在右移时带上进位标记，如 8086 中的 `rcr` 指令）。

#### 2.6.2. Approach 3

![|518](https://static.memset0.cn/img/v6/2024/09/23/8erWNFxv.png)

**具体过程**：先将 Multiplexer 放到 Product 寄存器的低 64 位，然后执行以下步骤 64 次：

1. 判断 Product 寄存器的最低位是否是 1：
2. 如果是，则将 Multiplicand 寄存器的值加到 Product 寄存器的左半部分里；
3. 如果否，进入下一步；
4. 将 Product 寄存器的值右移一位；
5. 判断是否做满 64 次，决定是否终止；

#### 2.6.3. Signed Multiplication

1. 先保存操作数的符号位，

#### 2.6.4. Faster Multiplication

![|641](https://static.memset0.cn/img/v6/2024/09/23/oM89d3SP.png)

## 3. Useful Links

- [3 Arithmetic - 咸鱼暄的代码空间 (xuan-insr.github.io)](https://xuan-insr.github.io/computer_organization/3_arithmetic/)
- [指令：计算机的语言 - HobbitQia 的笔记本](https://note.hobbitqia.cc/CO/co2/)
