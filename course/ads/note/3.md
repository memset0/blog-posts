---
title: III Mergeable Heaps
sync: /course/ads/note/3.md
---

## 1. 左倾堆

**空路径长度(null path length)**：$Npl(X)$ 定义为从节点 $X$ 任意没有两个孩子的子节点的最短距离。特别地，定义 $Npl(\text{NULL})=-1$，对于叶子节点或只有一个孩子的子节点，其 $Npl$ 显然为 $0$。显然有：

$$
Npl(X)= 1+\min\{Npl(C) \mid C \text{ is a child of } X\}
$$

**左倾堆(leftist heap)**：对于左倾堆的每个节点，其左节点的 $Npl$ 值大于等于右节点的 $Npl$ 值。

### 1.1. 合并

递归合并，每次插入到右侧。插入后如果右子树的 $Npl$ 更大则交换左右子树。

也有一种不“交换”左右孩子的方法，定义一个 $rc$ 函数每次根据左右孩子的 $Npl$ 返回 $Npl$ 较小的店作为右节点即可。

### 1.2. 更多操作

#### 1.2.1. 压入

看做与一个单节点的子树合并。

#### 1.2.2. 弹出

删去根，合并根节点的两个子树。

## 2. 斜堆

**斜堆(Skew Heap)**，也叫做**自适应堆(self-adjusting heap)** 是另一种可并堆，它不需要记录任意一个节点的距离，只是在合并操作上有所改变。

### 2.1. 合并

> 下面两种合并的方法都摘抄自 Wikipedia.

#### 2.1.1. 递归合并

- 比较两个堆；设 $p$ 是具有更小的 $root$ 的键值的堆，$q$ 是另一个堆，$r$ 是合并后的结果堆。
- 令 $r$ 的 $root$ 是 $p$（具有最小 $root$ 键值），$r$ 的右子树为 $p$ 的左子树。
- 令 $r$ 的左子树为 $p$ 的右子树与 $q$ 合并的结果。

![400](https://static.memset0.cn/img/v6/2024/03/18/5AvjjzEn.png)

#### 2.1.2. 非递归合并

- 把每个堆的每棵（递归意义下）最右子树切下来。这使得得到的每棵树的右子树均为空。
- 按 $root$ 的键值的升序排列这些树。
- 迭代合并具有最大 $root$ 键值的两棵树：
    - 具有次大 $root$ 键值的树的右子树必定为空。把其左子树与右子树交换。现在该树的左子树为空。
    - 具有最大 $root$ 键值的树作为具有次大 $root$ 键值树的左子树。

![|280](https://static.memset0.cn/img/v6/2024/03/18/llycHoJp.png)

### 2.2. 复杂度分析

**重节点(heavy node)**：称一个节点 $p$ 是 heavy 的，当且仅当它右子树的节点数大于等于左子树的节点数。

进行均摊分析，定义势能函数
$$
\Phi(D_i) = \text{the number of heavy nodes}
$$

考虑第 $i$ 次合并过程，它们**右路径上的**轻重节点个数分别为 $l_p,\ h_p$ 和 $l_q,\ h_q$。则一次合并的实际代价为

$$
c_i = l_p+ l_q+h_p+h_q
$$

另外注意到，一次操作后，重节点一定变成轻节点，但是轻节点不一定变成重节点。这是因为

- 对于一个重节点，原先较大的右子树交换到右侧且会与另一棵树合并，从而变得更大，故重节点合并后一定变成轻节点。
- 对于一个轻节点，虽然较重的子树被换到右侧，但是由于左子树和另一个树合并可能变得更大，故合并后有可能是轻节点也有可能是重节点。

故势能增加量

$$
\Phi(D_{i+1}) - \Phi(D_i) \leq l_p+l_q-h_p-h_q = O(\log N)
$$

而右路径上的轻节点的数是 $O(\log n)$ 级别的，所以总复杂度为 $O(n\log n)$。