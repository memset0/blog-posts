---
title: I 平衡树
sync: /course/ads/note/1.md
---
>[!quote]- 单词表
> - **兄弟节点(sibling)**



## 1. AVL 树

> [!info]- Fun Fact：AVL 树名字的由来
>
> Adelson-Velskii-Landis Trees 分别是论文的三位作者的名字。

### 1.1. 性质

1. 空二叉树是一个 **AVL 树(AVL Tree)**。
2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \le 1$，其中 $h(x)$ 是子树 $x$ 的高度。
3. 树高为 $O(\log n)$。

**平衡因子(Balance Factor)**：右子树高度 $-$ 左子树高度。（按照定义，对于任意节点都有 $BF(\text{node})=-1,0\text{ or } 1$）

>[!example]- 证明：树高为 O(log n)
>用 $f_n$ 表示树高为 $n$ 的 AVL 树最少有多少个节点。
> $$
>f_n = \left\{\begin{aligned}
>&1\quad&(n=1)\\
>&2\quad&(n=2)\\
>&f_{n-1} + f_{n-2} + 1 \quad&(n>2)\\
>\end{aligned}\right.
>$$
>注意到 $f_n$ 的通项是类似于斐波那契数列的。同理树高为 $n$ 的 AVL 树最多的节点数 $g_n$ 也是指数级的，故 AVL 树的树高为 $\Theta(\log n)$。

### 1.2. 插入

先与一般的二叉平衡树类似，先进行一次失败的查找，可以定位要插入的位置。插入的位置一定是一个叶子节点。之后自底向上检查有没有节点的平衡被破坏，如果有，其 $BF$ 值要么为 $-2$ 要么为 $2$。我们分类讨论进行调整。

称平衡被破坏的节点为**失衡节点(trouble finder)**，导致平衡被破坏的节点（即刚插入的节点）为**肇事者(trouble maker)**，只需要对于 trouble finder & maker 之间的子树进行调整。

在调整平衡时，我们只需要关注 trouble finder：
- 是左子树偏重（$BF = -2$）还是右子树偏重（$BF = 2$）？
- 是偏重的子树的左子树偏重还是偏重的子树的右子树偏重？

这里以左子树偏重（$BF = -2$）为例，右子树偏重的情况是对称的。当左子树的左子树偏重（$\text{height}[A]\ge \text{height}[C]$）时，需要执行**单旋(single rotation)**：

![单旋（红色标注的是树高）|35em](https://static.memset0.cn/img/v6/2024/02/26/bT4d0Ls7.png)

>[!hint] Hint：AVL 树的左旋和右旋
>重点关注蓝框框出的节点在旋转前后的变化（右旋的情况与左旋对称）。

当左子树的右子树偏重时（$\text{height}[A]< \text{height}[C]$），需要执行**双旋(double rotation)**：

![双旋|35em](https://static.memset0.cn/img/v6/2024/02/26/Yad7iBp1.png)

>[!warning]- Q：为什么双旋？
>观察需要被旋转的点（$D,B,C$），只通过一次旋转不能维护其中序遍历不变的性质。

容易发现，只需要在离 trouble maker 最近的 trouble finder 处进行一次单旋或双旋即可，因为旋转后 trouble finder 处的树高与插入节点前相同，在它上面的节点的 BF 值应与插入节点前相同。

维护平衡操作的伪代码如下：

```plain
Maintain-Balanced(p)
    if h[ls[p]] - h[rs[p]] == 2
        if h[ls[ls[p]]] >= h[rs[ls[p]]]
            Right-Rotate(p)
        else
            Left-Rotate(ls[p])
            Right-Rotate(p)
    else if h[ls[p]] - h[rs[p]] == -2
        if h[ls[rs[p]]] <= h[rs[rs[p]]]
            Left-Rotate(p)
        else
            Right-Rotate(rs[p])
            Left-Rotate(p)
```


### 1.3. 删除

先定位要删除的节点，如果是叶子则直接删除，否则找到其前驱（左子树中最右的节点）或后继（右子树中最左的节点）将其替换。这样可以保证每次删除操作实际删掉的点一定是叶子。

删除节点后也要应用调整操作，维护平衡的方法类似插入操作。


> [!quote] Useful Links
> -  [Lecture 1 | AVL Trees & Splay Trees - Isshiki修's Notebook (isshikih.top)](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/Lec01/)
> - [AVL 树 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/avl/)

## 2. 生长树

### 2.1. 性质

- **生长树(Splay Tree)** 单次操作的**均摊成本(averaged cost)** 为 $O(\log n)$，但最坏情况下单次是 $O(n)$ 的。

### 2.2. 旋转

Splay 树的核心思想是每次将被访问的节点旋转到根，称为 Splay 操作。如果还是用前面的旋转方式，复杂度是可能被卡到 $O(n^2)$ 的：

![|30em](https://static.memset0.cn/img/v6/2024/02/26/qXVDgA80.png)


这里需要引入 Splay 特有的旋转方式。设当前节点 $X$ 的父节点为 $P$，父节点的父节点为 $G$ 都存在。定义对 $X$ 的旋转操作 $Rotate(X)$ 为将 $X$ 旋转到 $P$ 的位置，即 $X$ 的父亲将变为 $G$，且维持平衡树的中序遍历不变。当 $X$ 是 $P$ 的左孩子时定义这样的旋转为右旋，当 $X$ 是 $P$ 的右孩子时定义这样的旋转为左旋。

注意这里的 $Rotate$ 函数的参数和上文 AVL 树中的说法并不一样，即 $Rotate(X)$ 对应着 $LeftRotate(P)$ 或 $RightRotate(P)$，至于到底是哪个取决于 $X$ 和 $P$ 的位置关系。

![（这里红色节点代表 X，黄色节点代表 P）|40em](https://static.memset0.cn/img/v6/2024/02/26/gn7NSlBu.png)

可以通过精巧的实现让代码自行决定左旋还是右旋，下文我们也直接用 $Rotate$ 操作来表示（自动决定的）左旋或右旋。

接下来：讨论 $X,P,G$ 是否在同一直线上。若在，则应用 Zig-Zig 旋转 $Rotate(P),\,Rotate(X)$：

![Zig-Zig|30em](https://static.memset0.cn/img/v6/2024/02/26/5hObMV2e.png)

若不在，则应用 Zig-Zag 旋转 $Rotate(X),\,Rotate(X)$：

![Zig-Zag|30em](https://static.memset0.cn/img/v6/2024/02/26/E1wvUUKl.png)

这样子 Splay 树的复杂度将会得到保证，具体证明参见下面的**均摊分析(amortized analysis)** 环节。

### 2.3. 均摊分析

**均摊分析(amortized analysis)** 分为三种：

- **聚合分析(aggregate analysis)**：总时间复杂度为 $T(n)$，则单次操作的均摊复杂度为 $T(n)/n$。
- **核算法(accounting method)**：每消耗 $1$ 的时间进行操作，就为之后的操作累计 $1$ 的信用。操作要么消耗时间要么消耗信用。
- **势能法(potential method)**：利用势能函数进行分析。

> [!important] 均摊分析之势能法
>
> 定义 $c_i$ 表示第 $i$ 次操作的实际成本，$\hat{c_i}$ 表示第 $i$ 次操作后的均摊成本。$D_i$ 表示第 $i$ 次操作后的数据结构，$\Phi(D_i)$ 表示第 $i$ 次操作后的势能函数。我们有：
> $$
> \hat{c_i} - c_i = Credit_i = \Phi(D_i) - \Phi(D_{i-1}) 
> $$
>
> $$
> \begin{aligned}
> \sum_{i=1}^n \hat{c_i} &= \sum_{i=1}^n \left(c_i + \Phi(D_i) - \Phi(D_{i-1})\right)\\
> &= \left(\sum_{i=1}^n c_i\right) + \Phi(D_n) - \Phi(D_0)
> \end{aligned}
> $$
>
> 只需要对于所有 $n$ 都满足 $\Phi(D_n)-\Phi(D_0)\ge 0$，就可以用均摊成本来确定实际成本的上限。一个好的势能函数的实现应该有 $\Phi(D_0)=0$，这样只需 $\Phi(D_n)\ge 0 = \Phi(D_0)$。
>

现在问题的关键在于确定势能函数。如果简单的将节点高度和定义为势能函数，虽然量级正确了，但是在 Splay 的过程中有许多节点的高度会发生变化，且数量不确定，这样定义的势能函数很难分析。

一个可用的势能函数是树中所有节点的 $\text{rank}$ 之和，我们用 $R(i)$ 表示节点 $i$ 的 $\text{rank}$，有
$$
R(i) = \log S(i)
$$

- 对于 Zig 操作，我们有：
  $$
  \hat{c_i} = 1+R_i(X)-R_{i-1}(X) +R_i(P)-R_{i-1}(P)
  $$
  由于 $P$ 从根节点变成非根节点，故 $R_i(P)-R_{i-1}(P)\le 0$，因此 $\hat{c_i}\le 1+R_i(X)-R_{i-1}(X)$。

- 对于 Zig-Zag 操作，我们有：
  $$
  \hat{c_i} = 2+R_i(X)-R_{i-1}(X)+R_i(P)-R_{i-1}(P)+R_i(G)-R_{i-1}(G)
  $$
  

## 3. 红黑树


## 4. B+ 树
