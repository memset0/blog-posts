---
title: I 平衡树
sync: /course/ads/note/1.md
---

## 1. AVL 树

> [!info]- AVL 树名字的由来
>
> Adelson-Velskii-Landis Trees 分别是论文的三位作者的名字。

### 1.1. 性质

1. 空二叉树是一个 **AVL 树(AVL Tree)**。
2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \le 1$，其中 $h(x)$ 是子树 $x$ 的高度。
3. 树高为 $O(\log n)$。

**平衡因子(Balance Factor)**：右子树高度 - 左子树高度。（按照定义，对于任意节点都有 $BF(\text{node})=-1,0\text{ or } 1$。）

>[!example]- 证明：树高为 O(log n)
>用 $f_n$ 表示树高为 $n$ 的 AVL 树最少有多少个节点。
> $$
>f_n = \left\{\begin{aligned}
>&1\quad&(n=1)\\
>&2\quad&(n=2)\\
>&f_{n-1} + f_{n-2} + 1 \quad&(n>2)\\
>\end{aligned}\right.
>$$
>注意到 $f_n$ 的通项是类似于斐波那契数列的。同理树高为 $n$ 的 AVL 树最多的节点数 $g_n$ 也是指数级的，故 AVL 树的树高为 $\Theta(\log n)$。

### 1.2. 插入

先与一般的二叉平衡树类似，先进行一次失败的查找，可以定位要插入的位置。插入的位置一定是一个叶子节点。之后自底向上检查有没有节点的平衡被破坏，如果有，其 BF 值要么为 $-2$ 要么为 $2$。我们分类讨论进行调整。

称平衡被破坏的节点为**失衡节点(trouble finder)**，导致平衡被破坏的节点（即刚插入的节点）为**肇事者(trouble maker)**，只需要对于 trouble finder & maker 之间的子树进行调整。

在调整平衡时，我们只需要关注 trouble finder：
- 是左子树偏重（$BF = -2$）还是右子树偏重（$BF = 2$）？
- 是偏重的子树的左子树偏重还是偏重的子树的右子树偏重？

这里以左子树偏重（$BF = -2$）为例，右子树偏重的情况是对称的。当左子树的左子树偏重（$\text{height}[A]\ge \text{height}[C]$）时，需要执行**单旋(single rotation)**：

![单旋（红色标注的是树高）|](https://static.memset0.cn/img/v6/2024/02/26/9dUetiBK.png)

当左子树的右子树偏重时（$\text{height}[A]< \text{height}[C]$），需要执行**双旋(double rotation)**：

![双旋|](https://static.memset0.cn/img/v6/2024/02/26/Yad7iBp1.png)

容易发现，只需要在离 trouble maker 最近的 trouble finder 处进行一次单旋或双旋即可，因为旋转后 trouble finder 处的树高与插入节点前相同，在它上面的节点的 BF 值应与插入节点前相同。

维护平衡操作的伪代码如下：

```plain
Maintain-Balanced(p)
    if h[ls[p]] - h[rs[p]] == 2
        if h[ls[ls[p]]] >= h[rs[ls[p]]]
            Right-Rotate(p)
        else
            Left-Rotate(ls[p])
            Right-Rotate(p)
    else if h[ls[p]] - h[rs[p]] == -2
        if h[ls[rs[p]]] <= h[rs[rs[p]]]
            Left-Rotate(p)
        else
            Right-Rotate(rs[p])
            Left-Rotate(p)
```


### 1.3. 删除

先定位要删除的节点，如果是叶子则直接删除，否则找到其前驱（左子树中最右的节点）或后继（右子树中最左的节点）将其替换。这样可以保证每次删除操作实际删掉的点一定是叶子。

删除节点后也要应用调整操作，维护平衡的方法类似插入操作。

## 2. 生长树

### 2.1. 性质

- **生长树(Splay Tree)** 单次操作的**均摊成本(averaged cost)** 为 $O(\log n)$，但最坏情况下单次是 $O(n)$ 的。

Splay 树的一个重要性质是每次会将被访问的节点旋转到根，如果还是用前面的旋转方式，复杂度是可能被卡到 $O(n^2)$ 的：

![](https://static.memset0.cn/img/v6/2024/02/26/9ntja99l.png)




## 3. 红黑树



