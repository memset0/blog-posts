---
title: I 平衡树
sync: /course/ads/note/1.md
---

## 1. AVL 树

> [!info]- AVL 树名字的由来
>
> Adelson-Velskii-Landis Trees 分别是论文的三位作者的名字。

### 1.1. 性质

1. 空二叉树是一个 **AVL 树(AVL Tree)**。
2. 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $|h(ls) - h(rs)| \le 1$，其中 $h(x)$ 是子树 $x$ 的高度。
3. 树高为 $O(\log n)$。

**平衡因子(Balance Factor)**：右子树高度 - 左子树高度。（按照定义，对于任意节点都有 $BF(\text{node})=-1,0\text{ or } 1$。）

>[!example]- 证明：树高为 O(log n)
>用 $f_n$ 表示树高为 $n$ 的 AVL 树最少有多少个节点。
> $$
>f_n = \left\{\begin{aligned}
>&1\quad&(n=1)\\
>&2\quad&(n=2)\\
>&f_{n-1} + f_{n-2} + 1 \quad&(n>2)\\
>\end{aligned}\right.
>$$
>注意到 $f_n$ 的通项是类似于斐波那契数列的。同理树高为 $n$ 的 AVL 树最多的节点数 $g_n$ 也是指数级的，故 AVL 树的树高为 $\Theta(\log n)$。

### 1.2. 插入

先与一般的二叉平衡树类似，先进行一次失败的查找，可以定位要插入的位置。插入的位置一定是一个叶子节点。之后自底向上检查有没有节点的平衡被破坏，如果有，其 BF 值要么为 $-2$ 要么为 $2$。我们分类讨论进行调整。

称平衡被破坏的节点为**失衡节点(trouble finder)**，导致平衡被破坏的节点（即刚插入的节点）为**肇事者(trouble maker)**，只需要对于 trouble finder & maker 之间的子树进行调整。

在调整平衡时，我们只需要关注 trouble finder：
- 是左子树偏重（$BF = -2$）还是右子树偏重（$BF = 2$）？
- 是偏重的子树的左子树偏重还是偏重的子树的右子树偏重？

这里以左子树偏重（$BF = -2$）为例，右子树偏重的情况是对称的。当左子树的左子树偏重（$\text{height}[A]\ge \text{height}[C]$）时，需要执行**单旋(single rotation)**：

![单旋（红色标注的是树高）|35em](https://static.memset0.cn/img/v6/2024/02/26/9dUetiBK.png)

当左子树的右子树偏重时（$\text{height}[A]< \text{height}[C]$），需要执行**双旋(double rotation)**：

![双旋|35em](https://static.memset0.cn/img/v6/2024/02/26/Yad7iBp1.png)

容易发现，只需要在离 trouble maker 最近的 trouble finder 处进行一次单旋或双旋即可，因为旋转后 trouble finder 处的树高与插入节点前相同，在它上面的节点的 BF 值应与插入节点前相同。

维护平衡操作的伪代码如下：

```plain
Maintain-Balanced(p)
    if h[ls[p]] - h[rs[p]] == 2
        if h[ls[ls[p]]] >= h[rs[ls[p]]]
            Right-Rotate(p)
        else
            Left-Rotate(ls[p])
            Right-Rotate(p)
    else if h[ls[p]] - h[rs[p]] == -2
        if h[ls[rs[p]]] <= h[rs[rs[p]]]
            Left-Rotate(p)
        else
            Right-Rotate(rs[p])
            Left-Rotate(p)
```


### 1.3. 删除

先定位要删除的节点，如果是叶子则直接删除，否则找到其前驱（左子树中最右的节点）或后继（右子树中最左的节点）将其替换。这样可以保证每次删除操作实际删掉的点一定是叶子。

删除节点后也要应用调整操作，维护平衡的方法类似插入操作。

## 2. 生长树

### 2.1. 性质

- **生长树(Splay Tree)** 单次操作的**均摊成本(averaged cost)** 为 $O(\log n)$，但最坏情况下单次是 $O(n)$ 的。

### 2.2. 旋转

Splay 树的核心思想是每次将被访问的节点旋转到根，称为 Splay 操作。如果还是用前面的旋转方式，复杂度是可能被卡到 $O(n^2)$ 的：

![|30em](https://static.memset0.cn/img/v6/2024/02/26/qXVDgA80.png)


这里需要引入 Splay 特有的旋转方式。设当前节点 $X$ 的父节点为 $P$，父节点的父节点为 $G$ 都存在。定义对 $X$ 的旋转操作 $Rotate(X)$ 为将 $X$ 旋转到 $P$ 的位置，即 $X$ 的父亲将变为 $G$，且维持平衡树的中序遍历不变。当 $X$ 是 $P$ 的左孩子时定义这样的旋转为左旋，当 $X$ 是 $P$ 的右孩子时定义这样的旋转为右旋。这里的左旋与右旋的定义和上文 AVL 树中的定义并不一样。

![|40em](https://static.memset0.cn/img/v6/2024/02/26/gn7NSlBu.png)

可以通过精巧的实现让代码自行决定左旋还是右旋，下文我们也直接用 $Rotate$ 操作来表示（自动决定的）左旋或右旋。

接下来：讨论 $X,P,G$ 是否在同一直线上。若在，则应用 Zig-Zig 旋转 $Rotate(X),\,Rotate(X)$：

![Zig-Zig|30em](https://static.memset0.cn/img/v6/2024/02/26/5hObMV2e.png)

若不在，则应用 Zig-Zag 旋转 $Rotate(P),\,Rotate(X)$：

![Zig-Zag|30em](https://static.memset0.cn/img/v6/2024/02/26/E1wvUUKl.png)

这样子 Splay 树的复杂度将会得到保证，具体证明参见下面的**均摊分析(amortized analysis)** 环节。

### 2.3. 均摊分析

定义 $c_i$ 表示第 $i$ 次操作的实际成本，$\hat{c_i}$ 表示第 $i$ 次操作后的均摊成本。$D_i$ 表示第 $i$ 次操作后的数据结构，$\Phi(D_i)$ 表示第 $i$ 次操作后的势能函数。我们有：

$$
\hat{c_i} - c_i = Credit_i = \Phi(D_i) - \Phi(D_{i-1}) 
$$

$$
\begin{aligned}
\sum_{i=1}^n \hat{c_i} &= \sum_{i=1}^n \left(c_i + \Phi(D_i) - \Phi(D_{i-1})\right)\\
&= \left(\sum_{i=1}^n c_i\right) + \Phi(D_n) - \Phi(D_0)
\end{aligned}
$$

只需要对于所有 $n$ 都满足 $\Phi(D_n)-\Phi(D_0)\ge 0$，就可以用均摊成本来确定实际成本的上限。一个好的势能函数的实现应该有 $\Phi(D_0)=0$，这样只需 $\Phi(D_n)\ge 0 = \Phi(D_0)$。

## 3. 红黑树


## 4. B+ 树



> [!quote] Useful Links
> -  [Lecture 1 | AVL Trees & Splay Trees - Isshiki修's Notebook (isshikih.top)](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/Lec01/)